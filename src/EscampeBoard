// Bibliothéque utilisées 
import java.io.File;
import java.io.FileWriter; 
import java.util.Scanner;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;


public class EscampeBoard implements Partie1 {
   
    private static final int[][] TAB_LISERE = {
        {1,2,2,3,1,2},
        {3,1,3,1,3,2},
        {2,3,1,2,1,3},
        {2,1,3,2,3,1},
        {1,3,1,3,1,2},
        {3,2,2,1,3,2}
    };
    private final char[][] board = new char[6][6];
    private Boolean blackOnTop = null;

    public getTabLisere(){
        return TAB_LISERE;
    }
    
    private void resetState(){
        // vidé le tableau board s'il contient autre chose du dernier modification. 
        for(int i=0; i<board.length; i++){
            for(int j=0; j<board.length; j++){
                //on remplace tous le contenu avec "-" qui signifie vide.
                board[i][j] ='-';
            }
        }
    }
    
    public void setFromFile(String fileName){
        resetState();
        File f = new File(fileName);
        String line;
        String lineModif;
        // Si le scanner ne réussit pas à lire le fichier, on envoie erreur pour dire que le fichier n'existe pas. 
        // try-with-ressources, le scanner sera fermer automatiquement à l'aide de try. 
        int r=0;
        try(Scanner reader = new Scanner(f)){
            while(reader.hasNextLine()){
                line = reader.nextLine().trim();
                // on enleve les espaces au début et à la fin de chaque ligne. 
                if(!line.startsWith("%") && !line.isEmpty()){
                    lineModif=line.substring(3,9);
                    for(int c=0; c < board[r].length; c++){
                        char ch = lineModif.charAt(c);
                        board[r][c] = ch; 
                    }
                    r++;
                }
            }             
        }
        catch(FileNotFoundException e){
            System.out.printf("Le fichier %s n'existe pas !!%n", fileName);
            e.printStackTrace();
        }

    }

    public void saveToFile(String fileName){
        String columns_letter = "%  ABCDEF\n";
        String lineContent; 
        int l=0;
        int num;
        try(FileWriter writer = new FileWriter(fileName)){
            // on écrit les lettres des colonnes ligne 1
            writer.write(columns_letter);
            for(l; l < board.length; l++){
                num = l + 1;
                lineContent= String.format(
                    "%02d %c%c%c%c%c%c %02d %n",
                     num, 
                     board[l][0], 
                     board[l][1], 
                     board[l][2], 
                     board[l][3], 
                     board[l][4], 
                     board[l][5],
                     num
                    );
                
                writer.write(lineContent);
            }
            // la derniere ligne avec les lettres des colonnes
            writer.write(columns_letter);
        }
        catch(IOException e){
            System.out.println("une erreur lors de l'ecriture dans le fichier");
            e.printStackTrace();
        }

    }

    // Vrai si player est bien "blanc" ou "noir"
    private boolean isValidPlayer(String player) {
        return "blanc".equals(player) || "noir".equals(player);
    }

    // Renvoie true si la case est dans le plateau 6x6
    private boolean inBounds(int r, int c) {
        return r >= 0 && r < board.length && c >= 0 && c < board[r].length;
    }

    // Convertit une coordonnée texte "B1" en indices (r,c) 0..5
    // Renvoie null si format invalide.
    private int[] parseSquare(String coord) {
        if (coord == null || coord.length() != 2) {
            return null;
        }
        char colChar = coord.charAt(0); // 'A'..'F'
        char rowChar = coord.charAt(1); // '1'..'6'

        if (colChar < 'A' || colChar > 'F') {
            return null;
        }
        if (rowChar < '1' || rowChar > '6') {
            return null;
        }
        int col = colChar - 'A';        // A->0, B->1...
        int row = rowChar - '1';        // '1'->0, '2'->1...

        return new int[]{row, col};
    }

    // Vrai si le pion à la case (r,c) appartient au joueur player
    private boolean isOwnPiece(int r, int c, String player) {
        char p = board[r][c];
        if ("blanc".equals(player)) {
            return p == 'b' || p == 'B';
        } else { // "noir"
            return p == 'n' || p == 'N';
        }
    }

    // Vrai si la case (r,c) contient une pièce adverse
    private boolean isOpponentPiece(int r, int c, String player) {
        char p = board[r][c];
        if ("blanc".equals(player)) {
            return p == 'n' || p == 'N';
        } else { // "noir"
            return p == 'b' || p == 'B';
        }
    }

    // Vrai si la case est vide
    private boolean isEmpty(int r, int c) {
        return board[r][c] == '-';
    }

    // Vrai si (rFrom,cFrom) -> (rTo,cTo) est un déplacement en ligne/colonne
    // avec distance exactement lisere et sans sauter par-dessus des pièces.
    private boolean isValidPath(int rFrom, int cFrom, int rTo, int cTo, int lisere) {
        int dr = rTo - rFrom;
        int dc = cTo - cFrom;

        // doit être en ligne ou col
        if (dr != 0 && dc != 0) {
            return false; // mouvement diagonal interdit (dans cette version simple)
        }

        int dist = Math.abs(dr) + Math.abs(dc);
        if (dist != lisere) {
            return false; // la distance ne correspond pas à la valeur du liséré
        }

        // vérifier qu’on ne saute pas par-dessus une pièce
        int stepR = Integer.compare(dr, 0); // peut retourner ces 3 valeurs : si dr<0 => -1, si dr>0 =>1 sinon 0 
        int stepC = Integer.compare(dc, 0);

        int r = rFrom + stepR;
        int c = cFrom + stepC;
        // on s’arrête AVANT la case d’arrivée
        while (r != rTo || c != cTo) {
            if (!isEmpty(r, c)) {
                return false; // il y a quelqu’un sur le chemin
            }
            r += stepR;
            c += stepC;
        }

        return true;
    }
    @Override
    public boolean isValidMove(String move, String player) {
        move = move.trim();

        if ("E".equals(move)) {
            return true;
        }
        // Vérifs de base ( si c'est null ou contient des espaces uniquement (vide))
        if (move == null || move.isBlank()) {
            return false;
        }
        if (!isValidPlayer(player)) {
            return false;
        }

        move = move.trim();

        // Cas placement (contient des '/')
        if (move.contains("/")) {
            return isValidPlacementMove(move, player);
        }

        // Cas coup "B1-D1"
        return isValidNormalMove(move, player);
    }

    /**
    * Vérifie un coup de type "B1-D1".
    */
    private boolean isValidNormalMove(String move, String player) {
        // format minimal "B1-D1" => longueur 5, '-' à la position 2
        if (move.length() != 5 || move.charAt(2) != '-') {
            return false;
        }

        String fromStr = move.substring(0, 2);
        String toStr   = move.substring(3, 5);

        int[] from = parseSquare(fromStr);
        int[] to   = parseSquare(toStr);
        if (from == null || to == null) {
            return false;
        }

        int rFrom = from[0], cFrom = from[1];
        int rTo   = to[0],   cTo   = to[1];

        if (!inBounds(rFrom, cFrom) || !inBounds(rTo, cTo)) {
            return false;
        }

        // case départ doit contenir une pièce du joueur
        if (!isOwnPiece(rFrom, cFrom, player)) {
            return false;
        }

        // case arrivée ne doit pas contenir une pièce à soi
        if (isOwnPiece(rTo, cTo, player)) {
            return false;
        }

        // récupérer la valeur du liséré pour la case de départ
        int lisere = TAB_LISERE[rFrom][cFrom];

        // vérifier le chemin (distance et obstacles)
        if (!isValidPath(rFrom, cFrom, rTo, cTo, lisere)) {
            return false;
        }

        // si on arrive ici, le coup est considéré valide
        return true;
    }

    /**
    * Vérifie un coup de placement "C6/A6/B5/D5/E6/F5".
    * Version simplifiée :
    *  - 6 positions,
    *  - dans le plateau,
    *  - cases vides,
    *  - pas de doublons.
    * À adapter si les règles imposent des zones de départ pour chaque joueur.
    */
    private boolean isValidPlacementMove(String move, String player) {
        String[] parts = move.split("/");

        // on s’attend à 6 positions
        if (parts.length != 6) {
            return false;
        }

        boolean[][] used = new boolean[6][6];

        // pour vérifier la zone à la fin, on mémorise les lignes utilisées
        int[] rows = new int[parts.length];
        int idx = 0;

        for (String p : parts) {
            int[] rc = parseSquare(p);   // rc[0] = row, rc[1] = col
            if (rc == null) {
                return false;
            }
            int r = rc[0], c = rc[1];

            if (!inBounds(r, c)) {
                return false;
            }
            if (!isEmpty(r, c)) {
                return false; // déjà occupé
            }
            if (used[r][c]) {
                return false; // doublon dans la liste
            }
            used[r][c] = true;

            rows[idx++] = r; // on garde la ligne pour la vérif de zone
        }

        // ---------- CONTRAINTE DE ZONE ----------

        // toutes les pièces doivent être dans 2 lignes consécutives d’un bord :
        // - soit lignes 0 et 1
        // - soit lignes 4 et 5

        if ("noir".equals(player)) {
            // est-ce que TOUT est sur 0–1 ?
            boolean allTop = true;
            // est-ce que TOUT est sur 4–5 ?
            boolean allBottom = true;

            for (int r : rows) {
                if (r != 0 && r != 1) {
                    allTop = false;
                }
                if (r != 4 && r != 5) {
                    allBottom = false;
                }
            }

            // si ce n’est ni tout en haut ni tout en bas → placement invalide
            if (!allTop && !allBottom) {
                return false;
            }

            // on mémorise le côté choisi par le joueur noir
            blackOnTop = allTop;
            return true;
        }

        // cas du joueur blanc : il doit être dans le camp opposé à celui du noir
        if ("blanc".equals(player)) {
            // si pour une raison quelconque le côté du noir n’est pas connu → invalide
            if (blackOnTop == null) {
                return false;
            }

            // si noir en haut (0–1), blanc doit être en bas (4–5), et inversement
            boolean blancDoitEtreEnBas  = blackOnTop;
            boolean blancDoitEtreEnHaut = !blackOnTop;

            for (int r : rows) {
                if (blancDoitEtreEnBas) {
                    if (r != 4 && r != 5) {
                        return false;
                    }
                } else if (blancDoitEtreEnHaut) {
                    if (r != 0 && r != 1) {
                        return false;
                    }
                }
            }
            return true;
        }

        // autre valeur de player → invalide
        return false;
    }


    @Override
    public String[] possiblesMoves(String player) {
        List<String> moves = new ArrayList<>();

        if (!isValidPlayer(player)) {
            return new String[0];
        }

        // Génération des déplacements pour chaque pièce du joueur
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {

                if (!isOwnPiece(r, c, player)) {
                    continue;
                }

                int lisere = TAB_LISERE[r][c];

                // on regarde les 4 directions (haut, bas, gauche, droite)
                int[][] dirs = {
                    {-1, 0}, // haut
                    { 1, 0}, // bas
                    { 0,-1}, // gauche
                    { 0, 1}  // droite
                };

                for (int[] d : dirs) {
                    int rTo = r + d[0] * lisere;
                    int cTo = c + d[1] * lisere;

                    if (!inBounds(rTo, cTo)) {
                        continue;
                    }

                    // ne pas atterrir sur une pièce à soi 
                    if (isOwnPiece(rTo, cTo, player)) {
                        continue;
                    }

                    if (!isValidPath(r, c, rTo, cTo, lisere)) {
                        continue;
                    }

                    // Construire le coup "B1-D1"
                    // ASCII : si c=0 -> 'A', c=1 -> 'B', ...
                    char colFrom = (char) ('A' + c);
                    char rowFrom = (char) ('1' + r);
                    char colTo   = (char) ('A' + cTo);
                    char rowTo   = (char) ('1' + rTo);

                    String move = "" + colFrom + rowFrom + "-" + colTo + rowTo;
                    moves.add(move);
                }
            }
        }
        
        return moves.toArray(new String[0]);
    }

    @Override
    public void play(String move, String player) {
        if (!isValidMove(move, player)) {
            throw new IllegalArgumentException("Coup invalide : " + move);
        }

        move = move.trim();

        // Cas spécial : le joueur passe son tour avec "E"
        if ("E".equals(move)) {
            // on ne modifie pas le plateau
            return;
        }

        // Cas placement
        if (move.contains("/")) {
            applyPlacementMove(move, player);
        } else {
            // Coup normal "B1-D1"
            applyNormalMove(move, player);
        }
    }

    // Joue un coup "B1-D1"
    private void applyNormalMove(String move, String player) {
        String fromStr = move.substring(0, 2);
        String toStr   = move.substring(3, 5);

        int[] from = parseSquare(fromStr);
        int[] to   = parseSquare(toStr);

        int rFrom = from[0], cFrom = from[1];
        int rTo   = to[0],   cTo   = to[1];

        char piece = board[rFrom][cFrom];
        board[rFrom][cFrom] = '-';   // case départ vidée
        board[rTo][cTo]     = piece; // on écrase éventuellement une pièce adverse
    }
    // Joue un coup de placement "C6/A6/B5/D5/E6/F5"
    private void applyPlacementMove(String move, String player) {
        String[] parts = move.split("/");

        char paladin = player.equals("blanc") ? 'b' : 'n'; // paladins
        char licorne = player.equals("blanc") ? 'B' : 'N'; // Licorne

        for (int i = 0; i < parts.length; i++) {
            int[] rc = parseSquare(parts[i]);
            int r = rc[0], c = rc[1];

            // la PREMIÈRE coordonnée correspond à la Licorne
            char piece = (i == 0) ? licorne : paladin;

            board[r][c] = piece;
        }
    }

    @Override
    public boolean gameOver() {
        boolean whiteKing = false;
        boolean blackKing = false;

        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {
                if (board[r][c] == 'B') {
                    whiteKing = true;
                } else if (board[r][c] == 'N') {
                    blackKing = true;
                }
            }
        }

        // partie terminée si au moins un roi manque
        return !whiteKing || !blackKing;
    }

}
